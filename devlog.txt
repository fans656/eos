2017-08-20 22:02:30
http://wiki.osdev.org/Rolling_Your_Own_Bootloader

Q: what is a bootloader?
A: the code executed on computer start up to load kernel from disk to memory


https://en.wikipedia.org/wiki/Real_mode

实模式和保护模式是x86系列CPU的历史遗留问题，80286引入保护模式之前只有实模式的存在，之后也为了兼容，开机首先还是进入实模式，然后通过代码(bootloader?)开启保护模式

保护模式提供访存限制、代码权限等功能——作为现代操作系统实现多任务进程隔离之类的基础

居然还有 long mode , 64位系统用的

https://en.wikipedia.org/wiki/A20_line
打开A20的故事


https://stackoverflow.com/questions/13132138/purest-way-to-assemble-compile-a-file-with-no-other-elf-object-bloat
gcc编译汇编代码


http://wiki.osdev.org/GDT
http://wiki.osdev.org/GDT_Tutorial
啊，实模式的时候就要设置GDT——用来描述segments的，比如哪些可执行，ring level是多少... 这些都是进入保护模式后就直接要用的
还要设置IDT，用来描述中断以及它们的handler的

2017-08-22 00:02:56
电脑启动后先执行BIOS的自检程序，然后加载硬盘的第一个扇区——如果这个扇区被视为bootable的话（即512字节的最后两个字节为0xaa55）
加载到内存的0x7c00处，然后跳转到这里开始继续执行

那么现阶段目标明确了：
在这512字节内实现一下INT 10H调用，在屏幕上显示点儿字儿

明儿应该就能搞出来吧，，之后各种捣鼓进保护模式，，保护模式之后就终于能往多任务、文件系统走了

2017-08-23 23:54:00
https://en.wikipedia.org/wiki/INT_10H

int 10h 还能画图啊，要不要在bootloader这儿多玩儿几天呢？用汇编去搞事情，画个 bad apple 什么的

https://everything2.com/title/Interrupt+10h

2017-08-24 23:25:03
https://en.wikibooks.org/wiki/X86_Assembly/Bootloaders

看这里的汇编想实践一下，不知道有啥好办法，，来看用gdb debug qemu

https://en.wikibooks.org/wiki/QEMU/Debugging_with_QEMU

2017-08-25 00:28:42
搞定了
    在虚拟机ubuntu里写asm
    nasm编译
    ndisasm + hexdump 瞅瞅
    curl 把 eos.img 发送给物理机(物理机上跑个python脚本拿flask接POST存文件)
    物理机手动运行debug.bat以debug模式启动qemu
    ubuntu里gdb target remote host:1234连上物理机
        layout asm
        layout regs
        continue
        si ... si si

看到 lodsb 原来除了把 ds:si 的内容移到 al 而且会自动把 si 加 1
然后 cld (clear direction，对应的是 std - set direction) 是保证这个 si 加1而不是减1

明儿把这个过程再自动化一点，不着急，慢慢来，总能把 int 10h 搞定的

之后应该是读盘的 int ，否则512字节蹦跶不了几天，，然后之后准备实模式的代码应该许多其实可以用C写了，，当然也免不了汇编

2017-08-26 00:10:30
达成成就：实模式下用 int 10h 显示 "hello eos!"
我擦，又过12点了，睡

2017-08-26 02:00:29
昨儿在卫生间看了点儿
原来实模式去保护模式要搞那么复杂的原因(setup一大堆什么descriptor)是两者访问内存的机制不同
实模式很简单，就是一个段寄存器+偏移寄存器，，然而保护模式下的段(segment)不能只用一个寄存器来描述了，
而要用一整个descriptor——一段8字节长的内存，里面存着段起始地址、privilege、executable、writable等信息
所以原理上就是用来描述 segment 的家伙从寄存器变成了descriptor
寄存器是直接硬件就有的，descriptor却需要我们自己去在内存里写相应的值，所以会麻烦
但理解了原理之后，剩下的就都是细节了

http://www.jamesmolloy.co.uk/tutorial_html/3.-The%20Screen.html
mark screen write

2017-08-26 14:07:05
https://stackoverflow.com/questions/14441215/bits-16-and-bits-32-in-nasm
nasm [bits 16] [bits 32]

http://www.rcollins.org/Productivity/NullDescriptor.html
GDT的第一个descriptor应该是null descriptor，这是规定，但是INTEL又说CPU永远不会reference这个descriptor
所以可以直接用它来存 lgdt 命令的数据：2字节GDT表的长度(减1)，4字节GDT表的首地址
(减1的原因是这里的长度取值 [0, 65536]，是用 [0,65535] 映射过去的)

2017-08-26 15:26:07
http://wiki.osdev.org/Global_Descriptor_Table
填充GDT entry时需要严重参考这个图

2017-08-26 15:56:39
达成成就：进入保护模式

2017-08-26 22:41:52
. understand assembly function
    call/ret/push/pop
) write a simple printf able to output
    ) null ended string
    ) arguments in stack

为什么stack是从高地址往低地址生长的呢？
可能根本原因是push指令被设计成是减sp吧~~
另外，是不是stack segment可以用上descriptor中那个direction属性了呢？空栈的话ss跟esp相等？

2017-08-27 10:17:56
为了想调函数(printf)于是需要用到栈，于是需要知道7c00的时候内存布局是什么样的：
哪些地方是BIOS？哪些地方是显存？那些地方是我可以用的？

http://wiki.osdev.org/Memory_Map_(x86)
这里说的很清楚

结论是至少从 7c00 的那512字节之后一直到 7ffff 统共480多k都是可以用的

2017-08-27 11:49:08
debug了半天——其实是人肉找错，有几个需要注意的地方：
    1. lodsb用的是 ds:esi，所以写显存时候另用一套 es:edi
    2. 不能在callee里直接 pop esi ，因为这时候栈顶存的是返回地址！参数都被压在返回地址下面呢，所以应该 mov esi, [esp + 4] (这也是c编译出来的汇编访问局部变量访问arguments的方法)
    3. 因为你的 CodeDescriptor 里 base 直接是 bits 32 部分的偏移量，所以引用 Message 的时候要用 Message - CODE_SEGMENT，即32位段里的相对偏移而不是你汇编里头的绝对偏移
别的没啥了，搞了个能显示 null ended 字符串的 printf
