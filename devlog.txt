2017-08-20 22:02:30
http://wiki.osdev.org/Rolling_Your_Own_Bootloader

Q: what is a bootloader?
A: the code executed on computer start up to load kernel from disk to memory


https://en.wikipedia.org/wiki/Real_mode

实模式和保护模式是x86系列CPU的历史遗留问题，80286引入保护模式之前只有实模式的存在，之后也为了兼容，开机首先还是进入实模式，然后通过代码(bootloader?)开启保护模式

保护模式提供访存限制、代码权限等功能——作为现代操作系统实现多任务进程隔离之类的基础

居然还有 long mode , 64位系统用的

https://en.wikipedia.org/wiki/A20_line
打开A20的故事


https://stackoverflow.com/questions/13132138/purest-way-to-assemble-compile-a-file-with-no-other-elf-object-bloat
gcc编译汇编代码


http://wiki.osdev.org/GDT
http://wiki.osdev.org/GDT_Tutorial
啊，实模式的时候就要设置GDT——用来描述segments的，比如哪些可执行，ring level是多少... 这些都是进入保护模式后就直接要用的
还要设置IDT，用来描述中断以及它们的handler的

2017-08-22 00:02:56
电脑启动后先执行BIOS的自检程序，然后加载硬盘的第一个扇区——如果这个扇区被视为bootable的话（即512字节的最后两个字节为0xaa55）
加载到内存的0x7c00处，然后跳转到这里开始继续执行

那么现阶段目标明确了：
在这512字节内实现一下INT 10H调用，在屏幕上显示点儿字儿

明儿应该就能搞出来吧，，之后各种捣鼓进保护模式，，保护模式之后就终于能往多任务、文件系统走了

2017-08-23 23:54:00
https://en.wikipedia.org/wiki/INT_10H

int 10h 还能画图啊，要不要在bootloader这儿多玩儿几天呢？用汇编去搞事情，画个 bad apple 什么的

https://everything2.com/title/Interrupt+10h

2017-08-24 23:25:03
https://en.wikibooks.org/wiki/X86_Assembly/Bootloaders

看这里的汇编想实践一下，不知道有啥好办法，，来看用gdb debug qemu

https://en.wikibooks.org/wiki/QEMU/Debugging_with_QEMU

2017-08-25 00:28:42
搞定了
    在虚拟机ubuntu里写asm
    nasm编译
    ndisasm + hexdump 瞅瞅
    curl 把 eos.img 发送给物理机(物理机上跑个python脚本拿flask接POST存文件)
    物理机手动运行debug.bat以debug模式启动qemu
    ubuntu里gdb target remote host:1234连上物理机
        layout asm
        layout regs
        continue
        si ... si si

看到 lodsb 原来除了把 ds:si 的内容移到 al 而且会自动把 si 加 1
然后 cld (clear direction，对应的是 std - set direction) 是保证这个 si 加1而不是减1

明儿把这个过程再自动化一点，不着急，慢慢来，总能把 int 10h 搞定的

之后应该是读盘的 int ，否则512字节蹦跶不了几天，，然后之后准备实模式的代码应该许多其实可以用C写了，，当然也免不了汇编

2017-08-26 00:10:30
达成成就：实模式下用 int 10h 显示 "hello eos!"
我擦，又过12点了，睡

2017-08-26 02:00:29
昨儿在卫生间看了点儿
原来实模式去保护模式要搞那么复杂的原因(setup一大堆什么descriptor)是两者访问内存的机制不同
实模式很简单，就是一个段寄存器+偏移寄存器，，然而保护模式下的段(segment)不能只用一个寄存器来描述了，
而要用一整个descriptor——一段8字节长的内存，里面存着段起始地址、privilege、executable、writable等信息
所以原理上就是用来描述 segment 的家伙从寄存器变成了descriptor
寄存器是直接硬件就有的，descriptor却需要我们自己去在内存里写相应的值，所以会麻烦
但理解了原理之后，剩下的就都是细节了

http://www.jamesmolloy.co.uk/tutorial_html/3.-The%20Screen.html
mark screen write

2017-08-26 14:07:05
https://stackoverflow.com/questions/14441215/bits-16-and-bits-32-in-nasm
nasm [bits 16] [bits 32]

http://www.rcollins.org/Productivity/NullDescriptor.html
GDT的第一个descriptor应该是null descriptor，这是规定，但是INTEL又说CPU永远不会reference这个descriptor
所以可以直接用它来存 lgdt 命令的数据：2字节GDT表的长度(减1)，4字节GDT表的首地址
(减1的原因是这里的长度取值 [0, 65536]，是用 [0,65535] 映射过去的)

2017-08-26 15:26:07
http://wiki.osdev.org/Global_Descriptor_Table
填充GDT entry时需要严重参考这个图

2017-08-26 15:56:39
达成成就：进入保护模式

2017-08-26 22:41:52
. understand assembly function
    call/ret/push/pop
. write a simple printf able to output
    . null ended string
    x arguments in stack

为什么stack是从高地址往低地址生长的呢？
可能根本原因是push指令被设计成是减sp吧~~
另外，是不是stack segment可以用上descriptor中那个direction属性了呢？空栈的话ss跟esp相等？

2017-08-27 10:17:56
为了想调函数(printf)于是需要用到栈，于是需要知道7c00的时候内存布局是什么样的：
哪些地方是BIOS？哪些地方是显存？那些地方是我可以用的？

http://wiki.osdev.org/Memory_Map_(x86)
这里说的很清楚

结论是至少从 7c00 的那512字节之后一直到 7ffff 统共480多k都是可以用的

2017-08-27 11:49:08
debug了半天——其实是人肉找错，有几个需要注意的地方：
    1. lodsb用的是 ds:esi，所以写显存时候另用一套 es:edi
    2. 不能在callee里直接 pop esi ，因为这时候栈顶存的是返回地址！参数都被压在返回地址下面呢，所以应该 mov esi, [esp + 4] (这也是c编译出来的汇编访问局部变量访问arguments的方法)
    3. 因为你的 CodeDescriptor 里 base 直接是 bits 32 部分的偏移量，所以引用 Message 的时候要用 Message - CODE_SEGMENT，即32位段里的相对偏移而不是你汇编里头的绝对偏移
别的没啥了，搞了个能显示 null ended 字符串的 printf

2017-08-27 13:44:40
) write code in C
) load sectors in 512B bootloader

2017-08-27 15:46:51
想用C来接着写，但是怎么把 kernel.c 变成可以由 bootloader 跳转过去的 raw binary 成为一个问题
查了好久没有好的解决办法，似乎正路是直接使用ELF格式——那么去(再度)看看ELF吧

2017-08-27 17:48:54
我靠，发现只需要一个code descriptor就好了额，，显存可以直接
    mov eax, 0b8000h
    mov word [eax], 0f41h
来写啊

2017-08-27 17:52:32
接下来试试把c编译出来的binary加载到内存，然后去执行

2017-08-27 21:16:09
实现了C语言写显存，爽！
整体过程是：
    bootloader.asm => 512B
    kernel.c => kernel.o => kernel.out (这一步要指定 .text 和 .data 的 org，具体方法见 build.sh)
    从 kernel.o 里 objcopy 出来所有的section拼成一个 kernel.img (小麻烦，要用dd在 .eh_frame 之后填充一定字节保证 .data 出现在 0x9000 的内存，因为 .text 里有引用)
    跟 bootloader 的 512字节 一块儿拼成 eos.img
    运行的时候 bootloader 加载其后的10个sector到内存0x8000，进入保护模式，跳转过去
C语言里就能直接写
    VIDEO_MEM[i] = 0x0f | ('0' + i);
啦~~

2017-08-27 21:53:10
接下来有无数方向，选什么样的路走呢？
暂觉这样：
先搞出来提示符 "> _"
和键盘输入
——键盘输入这一步就得涉及中断了，这个估计就得捣鼓一阵子
之后呢，嗯，应该开始支持跑程序，就得有文件系统
然后最好是能兼容ELF格式
这就是一堆操作系统需要提供的系统调用了

到了这里就是一个基本的DOS雏形
接下来就该是进程了
(虚拟内存是在这里么？)

进程完了，可以试试图形界面

到这里估摸着得一年了吧

再往后，网络协议栈

再往后呢？完善各种细节估计就可以搞很久，到时候看意愿吧
走到网络这一步，我们的mint也可以重拾起来了

那么，单机中的一个网络世界，乃至分布式，啥都可以搞
mint里支撑出的几个项目(redis? hadoop? kafka? p2p? ...)，以后也可以作为转行的资本了(如果毕业真的是在Amazon搞Android的话)

回到现实：命令行提示符，哈
> _

2017-08-30 08:50:40
protected mode 下不能用 BIOS，所以想改变光标位置得自己写 port 了 

http://wiki.osdev.org/Memory_Map_(x86)#BIOS_Data_Area_.28BDA.29
C语言写printf就简单多了，来写一个看一看EBDA有多大

2017-08-30 09:47:30
写的 print_str 在输出
    "_123456789_123456789_12345678"
时正常，但是输出
    "_123456789_123456789_123456789"
就奇怪了，前面缺了3个字符，输出成了
    3456789_123456789_123456789

看代码不该有这种现象啊，检查了下 ld 的 kernel.out
发现 .text 跟 .rodata 不是紧挨着的，.text 缺了3个字节，而 .rodata 是16字节对齐的

我擦，不是16字节对齐，是4字节对齐的

目前的这个跑c代码的方法只是临时hack，是根据 ld 的行为自己拼出来的 kernel image
之后肯定需要处理一下这儿的方法

0x40e处的word存的是EBDA的结束地址，开始地址是固定的0x9fc0
然后打印出来发现结束地址也是0x9fc0，那就是没有呗

我靠，也不是4字节，有时候还是2字节... nm你这到底是什么规律
不能猜了

2017-08-30 11:02:41
可以设置光标位置了

2017-08-30 12:21:03
.rodata 的起始位置确实没规律，得把C源码 => kernel image 这一步处理一下
正确做法大约就是在 bootloader 里解析 ELF 格式

2017-08-30 13:52:13
拿汇编解析ELF格式会是一场噩梦啊，拿python都那么麻烦了
刚厕所蹲一会儿忽然就想到，gcc输出ELF之后拿python提取所有section然后贴到合适的位置上去
生成的kernel image还是raw binary的

就这么搞

2017-08-30 14:47:18
拼的kernel image感觉没问题，但是跑不出效果，似乎是 .data 访问不到
检查了下地址，发现大于8K了，也就是说需要16个sector，而之前bootloader写的是加载10个sector
之前能跑是因为固定把.data放在0x9000的位置，10个sector就够

果然好了，，目前就把加载的sector个数固定写大点吧，64个sector支持32K的kernel
之后一切完成了回头再说支持第三方bootloader或者自己写能解析elf的bootloader

2017-08-30 16:55:47
https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html#Extended-Asm
在C语言里写汇编

http://www.osdev.org/howtos/2/
inb/outb

2017-08-30 22:20:53
https://stackoverflow.com/questions/3215878/what-are-in-out-instructions-in-x86-used-for/33444273#33444273
https://stackoverflow.com/questions/22054578/how-to-run-a-program-without-an-operating-system/32483545#32483545
mark一下这个答案，这个答主应该在一系列答案里其中某篇提到keyboard IO

2017-08-30 23:08:15
正确的读键盘输入的办法是用中断，即收到中断后去执行
    in 60, al
把scancode的byte读进来

但这里我先简单起见用polling的方式实现一下吧
先
    uint8_t status = inb(0x64);
    if (status & 0x01) {
        uint8_t scancode = inb(0x60);
    }
0x01 是 Output Buffer Status
(这里的input/output是相对于keyboard来说的，output就是keyboard产生了按键等待CPU去读)

http://wiki.osdev.org/%228042%22_PS/2_Controller
http://www.computer-engineering.org/ps2keyboard/scancodes1.html

2017-08-30 23:58:26
目前的源码文件：
    io.c
    kernel.c
    util.c
因为忽然多了io.c而编译的时候是 gcc *.c
于是编出来的 .text 里第一个函数不是 kernel_entry 了，于是崩了

所以hack之：把kernel.c重命名为0kernel.c，囧

2017-08-31 00:08:53
感觉下一步应该写个 printf / scanf
然后把 scancode set 1 完善一下(目前只处理了A-Z)
就能做一个简单的console了
甚至能做一个fake的贪吃蛇——一个写在内核里的贪吃蛇
(fake的意思是这货不是user space的程序)

嗯...要写贪吃蛇可能会需要涉及
    - 时钟
        sleep(100)
    - 中断
        poll key的while循环不能放在游戏逻辑里了
        否则玩家按一下“上”，小蛇是得能持续往上走的，这时不能在那while循环等输入

2017-08-31 08:21:38
实现一下中断

http://wiki.osdev.org/Interrupt_Descriptor_Table

2017-08-31 12:27:42
感觉知道上午interrupt搞不定是什么原因了：code descriptor 的 base 以前写的是 0x8000
而这里ISR的地址是(绝对)线性地址，就错了
在bootloader里把descriptor的base改成0x0000，就对了
